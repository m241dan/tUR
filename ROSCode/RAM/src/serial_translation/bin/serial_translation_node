#! /usr/bin/env python

import sys
import translation_layer.layer
import rospy
import serial
import struct
from binascii import hexlify
from std_msgs.msg import ByteMultiArray

PACKET_SIZE = 512

class SerialTranslationLayer:
    def __init__(self):
        self.port = rospy.get_param('~port', '/dev/ttyUSB0')
        self.baud = rospy.get_param('~baud', 4800)

        self.pub = rospy.Publisher("serial_output", ByteMultiArray, queue_size=10)
        self.sub = rospy.Subscriber("serial_input", ByteMultiArray, self.incomingFromGround)
        self.check_serial_timer = rospy.Timer(rospy.Duration(0.1), self.incomingFromRam)

        self.serial_handle = serial.Serial(
            port='/dev/ttyUSB0',
            baudrate=4800,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS
        )
        self.serial_handle.close()
        self.serial_handle.open()
        self.serial_handle.isOpen()

    def incomingFromGround(self, msg):
        rospy.loginfo( "Sending to RAM.." )
        ground_bytes = bytearray(len(msg.data))
        for data in msg.data:
            ground_bytes.append( data )


        self.serial_handle.flushOutput()
        self.serial_handle.write(str(ground_bytes))
        return

    def incomingFromRam(self, event):
        print "Receiving..." + str(self.serial_handle.inWaiting())
        if self.serial_handle.inWaiting() >= PACKET_SIZE:
            rospy.loginfo("Receiving from RAM...")
            ground_bytes = self.serial_handle.read( PACKET_SIZE )
            hex = hexlify(ground_bytes)

            msg = ByteMultiArray()
            for value in hex:
                msg.data.append(int(value, 16 ))
            self.pub.publish( msg )
        return

def main():
    rospy.init_node("serial_translation_node", sys.argv, anonymous=True)
    layer = SerialTranslationLayer()
    rospy.spin()


if __name__ == '__main__':
    main()
