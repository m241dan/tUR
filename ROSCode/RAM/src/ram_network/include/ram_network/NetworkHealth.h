// Generated by gencpp from file ram_network/NetworkHealth.msg
// DO NOT EDIT!


#ifndef RAM_NETWORK_MESSAGE_NETWORKHEALTH_H
#define RAM_NETWORK_MESSAGE_NETWORKHEALTH_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ram_network
{
template <class ContainerAllocator>
struct NetworkHealth_
{
  typedef NetworkHealth_<ContainerAllocator> Type;

  NetworkHealth_()
    : system_time(0)
    , serial_commands_received(0)
    , serial_gtp_received(0)
    , serial_connection_fault(0)
    , ada_commands_received(0)
    , ada_command_faults(0)
    , ada_writes_received(0)
    , ada_write_faults(0)
    , ada_reads_received(0)
    , ada_read_faults(0)
    , ada_sd_fault(0)
    , ada_connection_fault(0)
    , ada_bme01_fault(0)
    , ada_bme02_fault(0)
    , ada_eng_msg()
    , bbox_commands_received(0)
    , bbox_command_faults(0)
    , bbox_writes_received(0)
    , bbox_write_faults(0)
    , bbox_reads_received(0)
    , bbox_read_faults(0)
    , bbox_sd_fault(0)
    , bbox_connection_fault(0)
    , bbox_eng_msg()
    , ada_commands(0)
    , bbox_commands(0)
    , cam_commands(0)
    , arm_commands(0)
    , netw_commands(0)  {
    }
  NetworkHealth_(const ContainerAllocator& _alloc)
    : system_time(0)
    , serial_commands_received(0)
    , serial_gtp_received(0)
    , serial_connection_fault(0)
    , ada_commands_received(0)
    , ada_command_faults(0)
    , ada_writes_received(0)
    , ada_write_faults(0)
    , ada_reads_received(0)
    , ada_read_faults(0)
    , ada_sd_fault(0)
    , ada_connection_fault(0)
    , ada_bme01_fault(0)
    , ada_bme02_fault(0)
    , ada_eng_msg(_alloc)
    , bbox_commands_received(0)
    , bbox_command_faults(0)
    , bbox_writes_received(0)
    , bbox_write_faults(0)
    , bbox_reads_received(0)
    , bbox_read_faults(0)
    , bbox_sd_fault(0)
    , bbox_connection_fault(0)
    , bbox_eng_msg(_alloc)
    , ada_commands(0)
    , bbox_commands(0)
    , cam_commands(0)
    , arm_commands(0)
    , netw_commands(0)  {
  (void)_alloc;
    }



   typedef uint32_t _system_time_type;
  _system_time_type system_time;

   typedef uint32_t _serial_commands_received_type;
  _serial_commands_received_type serial_commands_received;

   typedef uint32_t _serial_gtp_received_type;
  _serial_gtp_received_type serial_gtp_received;

   typedef uint8_t _serial_connection_fault_type;
  _serial_connection_fault_type serial_connection_fault;

   typedef uint32_t _ada_commands_received_type;
  _ada_commands_received_type ada_commands_received;

   typedef uint32_t _ada_command_faults_type;
  _ada_command_faults_type ada_command_faults;

   typedef uint64_t _ada_writes_received_type;
  _ada_writes_received_type ada_writes_received;

   typedef uint32_t _ada_write_faults_type;
  _ada_write_faults_type ada_write_faults;

   typedef uint64_t _ada_reads_received_type;
  _ada_reads_received_type ada_reads_received;

   typedef uint32_t _ada_read_faults_type;
  _ada_read_faults_type ada_read_faults;

   typedef uint8_t _ada_sd_fault_type;
  _ada_sd_fault_type ada_sd_fault;

   typedef uint8_t _ada_connection_fault_type;
  _ada_connection_fault_type ada_connection_fault;

   typedef uint8_t _ada_bme01_fault_type;
  _ada_bme01_fault_type ada_bme01_fault;

   typedef uint8_t _ada_bme02_fault_type;
  _ada_bme02_fault_type ada_bme02_fault;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _ada_eng_msg_type;
  _ada_eng_msg_type ada_eng_msg;

   typedef uint32_t _bbox_commands_received_type;
  _bbox_commands_received_type bbox_commands_received;

   typedef uint32_t _bbox_command_faults_type;
  _bbox_command_faults_type bbox_command_faults;

   typedef uint64_t _bbox_writes_received_type;
  _bbox_writes_received_type bbox_writes_received;

   typedef uint32_t _bbox_write_faults_type;
  _bbox_write_faults_type bbox_write_faults;

   typedef uint64_t _bbox_reads_received_type;
  _bbox_reads_received_type bbox_reads_received;

   typedef uint32_t _bbox_read_faults_type;
  _bbox_read_faults_type bbox_read_faults;

   typedef uint8_t _bbox_sd_fault_type;
  _bbox_sd_fault_type bbox_sd_fault;

   typedef uint8_t _bbox_connection_fault_type;
  _bbox_connection_fault_type bbox_connection_fault;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _bbox_eng_msg_type;
  _bbox_eng_msg_type bbox_eng_msg;

   typedef uint8_t _ada_commands_type;
  _ada_commands_type ada_commands;

   typedef uint8_t _bbox_commands_type;
  _bbox_commands_type bbox_commands;

   typedef uint8_t _cam_commands_type;
  _cam_commands_type cam_commands;

   typedef uint8_t _arm_commands_type;
  _arm_commands_type arm_commands;

   typedef uint8_t _netw_commands_type;
  _netw_commands_type netw_commands;





  typedef boost::shared_ptr< ::ram_network::NetworkHealth_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ram_network::NetworkHealth_<ContainerAllocator> const> ConstPtr;

}; // struct NetworkHealth_

typedef ::ram_network::NetworkHealth_<std::allocator<void> > NetworkHealth;

typedef boost::shared_ptr< ::ram_network::NetworkHealth > NetworkHealthPtr;
typedef boost::shared_ptr< ::ram_network::NetworkHealth const> NetworkHealthConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ram_network::NetworkHealth_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ram_network::NetworkHealth_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ram_network

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'ram_network': ['/home/korisd/tUR/ROSCode/RAM/src/ram_network/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ram_network::NetworkHealth_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ram_network::NetworkHealth_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ram_network::NetworkHealth_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ram_network::NetworkHealth_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ram_network::NetworkHealth_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ram_network::NetworkHealth_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ram_network::NetworkHealth_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ba41344c2607351b1d0eeef5206f2e51";
  }

  static const char* value(const ::ram_network::NetworkHealth_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xba41344c2607351bULL;
  static const uint64_t static_value2 = 0x1d0eeef5206f2e51ULL;
};

template<class ContainerAllocator>
struct DataType< ::ram_network::NetworkHealth_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ram_network/NetworkHealth";
  }

  static const char* value(const ::ram_network::NetworkHealth_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ram_network::NetworkHealth_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint32 system_time\n\
uint32 serial_commands_received\n\
uint32 serial_gtp_received\n\
uint8 serial_connection_fault\n\
uint32 ada_commands_received\n\
uint32 ada_command_faults \n\
uint64 ada_writes_received\n\
uint32 ada_write_faults\n\
uint64 ada_reads_received\n\
uint32 ada_read_faults\n\
uint8 ada_sd_fault\n\
uint8 ada_connection_fault\n\
uint8 ada_bme01_fault \n\
uint8 ada_bme02_fault\n\
string ada_eng_msg\n\
uint32 bbox_commands_received \n\
uint32 bbox_command_faults \n\
uint64 bbox_writes_received\n\
uint32 bbox_write_faults\n\
uint64 bbox_reads_received\n\
uint32 bbox_read_faults\n\
uint8 bbox_sd_fault\n\
uint8 bbox_connection_fault\n\
string bbox_eng_msg\n\
uint8 ada_commands\n\
uint8 bbox_commands\n\
uint8 cam_commands\n\
uint8 arm_commands\n\
uint8 netw_commands\n\
";
  }

  static const char* value(const ::ram_network::NetworkHealth_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ram_network::NetworkHealth_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.system_time);
      stream.next(m.serial_commands_received);
      stream.next(m.serial_gtp_received);
      stream.next(m.serial_connection_fault);
      stream.next(m.ada_commands_received);
      stream.next(m.ada_command_faults);
      stream.next(m.ada_writes_received);
      stream.next(m.ada_write_faults);
      stream.next(m.ada_reads_received);
      stream.next(m.ada_read_faults);
      stream.next(m.ada_sd_fault);
      stream.next(m.ada_connection_fault);
      stream.next(m.ada_bme01_fault);
      stream.next(m.ada_bme02_fault);
      stream.next(m.ada_eng_msg);
      stream.next(m.bbox_commands_received);
      stream.next(m.bbox_command_faults);
      stream.next(m.bbox_writes_received);
      stream.next(m.bbox_write_faults);
      stream.next(m.bbox_reads_received);
      stream.next(m.bbox_read_faults);
      stream.next(m.bbox_sd_fault);
      stream.next(m.bbox_connection_fault);
      stream.next(m.bbox_eng_msg);
      stream.next(m.ada_commands);
      stream.next(m.bbox_commands);
      stream.next(m.cam_commands);
      stream.next(m.arm_commands);
      stream.next(m.netw_commands);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct NetworkHealth_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ram_network::NetworkHealth_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ram_network::NetworkHealth_<ContainerAllocator>& v)
  {
    s << indent << "system_time: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.system_time);
    s << indent << "serial_commands_received: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.serial_commands_received);
    s << indent << "serial_gtp_received: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.serial_gtp_received);
    s << indent << "serial_connection_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.serial_connection_fault);
    s << indent << "ada_commands_received: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ada_commands_received);
    s << indent << "ada_command_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ada_command_faults);
    s << indent << "ada_writes_received: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.ada_writes_received);
    s << indent << "ada_write_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ada_write_faults);
    s << indent << "ada_reads_received: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.ada_reads_received);
    s << indent << "ada_read_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ada_read_faults);
    s << indent << "ada_sd_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ada_sd_fault);
    s << indent << "ada_connection_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ada_connection_fault);
    s << indent << "ada_bme01_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ada_bme01_fault);
    s << indent << "ada_bme02_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ada_bme02_fault);
    s << indent << "ada_eng_msg: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.ada_eng_msg);
    s << indent << "bbox_commands_received: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.bbox_commands_received);
    s << indent << "bbox_command_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.bbox_command_faults);
    s << indent << "bbox_writes_received: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.bbox_writes_received);
    s << indent << "bbox_write_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.bbox_write_faults);
    s << indent << "bbox_reads_received: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.bbox_reads_received);
    s << indent << "bbox_read_faults: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.bbox_read_faults);
    s << indent << "bbox_sd_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bbox_sd_fault);
    s << indent << "bbox_connection_fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bbox_connection_fault);
    s << indent << "bbox_eng_msg: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.bbox_eng_msg);
    s << indent << "ada_commands: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ada_commands);
    s << indent << "bbox_commands: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bbox_commands);
    s << indent << "cam_commands: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cam_commands);
    s << indent << "arm_commands: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.arm_commands);
    s << indent << "netw_commands: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.netw_commands);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RAM_NETWORK_MESSAGE_NETWORKHEALTH_H
